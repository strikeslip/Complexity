<!--
[SOS - Sounds Of Seismic] - Granular Synthesis Generative Version
https://sos.allshookup.org/
Original Framework Copyright (c) [2025] [SHOOK aka D.V.R.]
Granular Synthesis Implementation based on THREE.html FM Architecture

SOS is free software: you can redistribute it and/or modify
it under the terms of the MIT License (https://opensource.org/license/mit)
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    <title>3THREE3 - Granular Seismic Synthesis</title>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: #101015;
            color: #e0e0e0;
            text-align: center;
            padding: 40px 20px;
            line-height: 1.6;
        }
        h1 { font-size: 2.2em; margin-bottom: 15px; color: #ff6f00; font-weight: 600; letter-spacing: 1px; }
        h2 { font-size: 1.1em; margin-bottom: 25px; color: #999; font-weight: 400; }
        button {
            background: #ff6f00; border: none; color: #101015; font-size: 18px; font-weight: 600;
            padding: 12px 28px; border-radius: 8px; cursor: pointer; margin: 10px 10px;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        button:hover { background: #ff8f33; }
        button:active { transform: scale(0.98); }
        button:disabled { background: #555; color: #888; cursor: not-allowed; }
        button.freeze-active { background: #00ccff; color: #101015; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .info { margin-top: 30px; font-size: 0.95em; color: #ccc; max-width: 600px; margin-left: auto; margin-right: auto; }
        .info strong { color: #ffaa00; }
        .info a { color: #66aaff; text-decoration: none; }
        .info a:hover { text-decoration: underline; }
        .error { color: #ff5555; font-weight: bold; margin-top: 20px; }
        .loading { margin-top: 20px; font-style: italic; color: #888; }
        .status-line { display: block; margin-bottom: 3px; }
        .cycle-info { margin-top: 15px; padding: 10px; background: #1a1a20; border-radius: 6px; font-family: monospace; font-size: 0.85em; }
        .cycle-info .param { color: #ff6f00; }
        .cycle-info .layer { color: #00ff88; }
        .controls-panel { margin-top: 20px; padding: 15px; background: #1a1a20; border-radius: 8px; max-width: 700px; margin-left: auto; margin-right: auto; }
        .control-row { display: flex; justify-content: center; align-items: center; gap: 15px; margin: 10px 0; flex-wrap: wrap; }
        .control-group { display: flex; flex-direction: column; align-items: center; min-width: 100px; }
        .control-group label { font-size: 0.75em; color: #888; margin-bottom: 5px; text-transform: uppercase; }
        .control-group input[type="range"] { width: 100px; accent-color: #ff6f00; }
        .control-group select { background: #252530; color: #e0e0e0; border: 1px solid #444; padding: 5px 10px; border-radius: 4px; font-size: 0.9em; }
        .control-group .value { font-size: 0.8em; color: #ff6f00; margin-top: 3px; }
        .waveform-container { margin: 20px auto; max-width: 700px; height: 120px; background: #0a0a0f; border-radius: 8px; position: relative; overflow: hidden; }
        #waveformCanvas { width: 100%; height: 100%; }
        .playhead { position: absolute; top: 0; width: 2px; height: 100%; background: #ff6f00; pointer-events: none; }
        .layer-toggles { display: flex; justify-content: center; gap: 10px; margin: 15px 0; }
        .layer-toggle { padding: 8px 16px; font-size: 0.85em; border-radius: 20px; }
        .layer-toggle.texture { background: #ff6f00; }
        .layer-toggle.tone { background: #00ff88; color: #101015; }
        .layer-toggle.rhythm { background: #00ccff; color: #101015; }
        .layer-toggle.inactive { background: #333; color: #666; }
        .preset-panel { margin: 20px auto; max-width: 700px; }
        .preset-row { display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; }
        .preset-btn { 
            background: #252530; 
            border: 2px solid #444; 
            color: #e0e0e0; 
            font-size: 14px; 
            font-weight: 500;
            padding: 10px 18px; 
            border-radius: 6px; 
            cursor: pointer; 
            transition: all 0.2s ease;
        }
        .preset-btn:hover { border-color: #ff6f00; background: #2a2a35; }
        .preset-btn.active { border-color: #ff6f00; background: #ff6f00; color: #101015; }
        .preset-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .preset-label { font-size: 0.75em; color: #888; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
        .preset-description { font-size: 0.7em; color: #666; margin-top: 4px; }
    </style>
</head>
<body>
    <h1>3THREE3</h1>
    <h2>Granular Seismic Synthesis • Layered Clouds • Harmonic Quantization</h2>
    
    <div class="waveform-container">
        <canvas id="waveformCanvas"></canvas>
        <div class="playhead" id="playhead"></div>
    </div>
    
    <button id="startButton">Start</button>
    <button id="stopButton" disabled>Stop</button>
    <button id="freezeButton" disabled>Freeze</button>
    
    <div class="layer-toggles">
        <button class="layer-toggle texture" id="toggleTexture">Texture</button>
        <button class="layer-toggle tone" id="toggleTone">Tone</button>
        <button class="layer-toggle rhythm" id="toggleRhythm">Rhythm</button>
    </div>
    
    <div class="preset-panel" id="presetPanel" style="display:none;">
        <div class="preset-label">Presets</div>
        <div class="preset-row">
            <button class="preset-btn" id="presetTectonic" title="Pentatonic • A2 • 2x Stretch • 30 g/s • 60% Reverb">
                Tectonic Ambient
                <div class="preset-description">Slow, expansive soundscape</div>
            </button>
            <button class="preset-btn" id="presetAftershock" title="Fifths • E2 • 0.5x Stretch • 80 g/s • 20% Reverb">
                Aftershock Pulse
                <div class="preset-description">Fast, rhythmic intensity</div>
            </button>
            <button class="preset-btn" id="presetSubduction" title="Harmonic • A1 • 4x Stretch • 15 g/s • 80% Reverb • Freeze on Peak">
                Subduction Drone
                <div class="preset-description">Deep drone with auto-freeze</div>
            </button>
        </div>
    </div>
    
    <div class="controls-panel" id="controlsPanel" style="display:none;">
        <div class="control-row">
            <div class="control-group">
                <label>Time Stretch</label>
                <input type="range" id="stretchSlider" min="0.25" max="4" step="0.25" value="1">
                <span class="value" id="stretchValue">1.0x</span>
            </div>
            <div class="control-group">
                <label>Density</label>
                <input type="range" id="densitySlider" min="5" max="100" step="5" value="30">
                <span class="value" id="densityValue">30 g/s</span>
            </div>
            <div class="control-group">
                <label>Grain Size</label>
                <input type="range" id="grainSizeSlider" min="10" max="200" step="10" value="50">
                <span class="value" id="grainSizeValue">50ms</span>
            </div>
        </div>
        <div class="control-row">
            <div class="control-group">
                <label>Scale</label>
                <select id="scaleSelect">
                    <option value="chromatic">Chromatic</option>
                    <option value="pentatonic" selected>Pentatonic</option>
                    <option value="minor">Minor</option>
                    <option value="major">Major</option>
                    <option value="fifths">Fifths</option>
                    <option value="harmonic">Harmonic Series</option>
                </select>
            </div>
            <div class="control-group">
                <label>Root Note</label>
                <select id="rootSelect">
                    <option value="55">A1 (55Hz)</option>
                    <option value="65.41">C2 (65Hz)</option>
                    <option value="82.41">E2 (82Hz)</option>
                    <option value="110" selected>A2 (110Hz)</option>
                    <option value="130.81">C3 (131Hz)</option>
                    <option value="220">A3 (220Hz)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Reverb</label>
                <input type="range" id="reverbSlider" min="0" max="100" step="5" value="40">
                <span class="value" id="reverbValue">40%</span>
            </div>
        </div>
    </div>
    
    <div id="statusInfo">Press Start to fetch seismic data and begin granular synthesis...</div>
    <div id="cycleInfo" class="cycle-info" style="display:none;"></div>

    <script>
        const SEISMIC_DATA_DURATION_S = 60;
        const SAMPLE_RATE = 44100;
        const MIN_MAGNITUDE = 6.0;
        const FETCH_TIMESPAN_DAYS = 30;
        const STATION_INFO = { net: "IU", sta: "ANMO", loc: "00", cha: "BHZ" };
        const CYCLE_DURATION_S = 31;

        const SCALES = {
            chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
            pentatonic: [0, 2, 4, 7, 9],
            minor: [0, 2, 3, 5, 7, 8, 10],
            major: [0, 2, 4, 5, 7, 9, 11],
            fifths: [0, 7, 14, 21],
            harmonic: [0, 12, 19, 24, 28, 31, 34, 36]
        };

        // Preset definitions
        const PRESETS = {
            tectonic: {
                name: 'Tectonic Ambient',
                scale: 'pentatonic',
                root: 110,      // A2
                stretch: 2,
                density: 30,
                reverb: 60,
                freezeOnPeak: false
            },
            aftershock: {
                name: 'Aftershock Pulse',
                scale: 'fifths',
                root: 82.41,    // E2
                stretch: 0.5,
                density: 80,
                reverb: 20,
                freezeOnPeak: false
            },
            subduction: {
                name: 'Subduction Drone',
                scale: 'harmonic',
                root: 55,       // A1
                stretch: 4,
                density: 15,
                reverb: 80,
                freezeOnPeak: true
            }
        };

        let audioCtx = null;
        let masterGain, compressor;
        let reverb, reverbWetGain;
        let delay, delayFeedbackGain, delayWetGain;
        let seismicData = [];
        let isPlaying = false;
        let isFrozen = false;
        let currentQuakeInfo = null;
        let cycleCount = 0;
        let granularEngine = null;
        let activeSchedulers = [];
        let waveformCtx = null;
        let subBassNodes = null;
        let layerStates = { texture: true, tone: true, rhythm: true };
        let currentPreset = null;
        let peakDetectionEnabled = false;
        let peakThreshold = 0.7;

        const startBtn = document.getElementById("startButton");
        const stopBtn = document.getElementById("stopButton");
        const freezeBtn = document.getElementById("freezeButton");
        const statusInfo = document.getElementById("statusInfo");
        const cycleInfo = document.getElementById("cycleInfo");
        const controlsPanel = document.getElementById("controlsPanel");
        const presetPanel = document.getElementById("presetPanel");
        const waveformCanvas = document.getElementById("waveformCanvas");
        const playheadEl = document.getElementById("playhead");
        const stretchSlider = document.getElementById("stretchSlider");
        const densitySlider = document.getElementById("densitySlider");
        const grainSizeSlider = document.getElementById("grainSizeSlider");
        const scaleSelect = document.getElementById("scaleSelect");
        const rootSelect = document.getElementById("rootSelect");
        const reverbSlider = document.getElementById("reverbSlider");

        const presetTectonicBtn = document.getElementById("presetTectonic");
        const presetAftershockBtn = document.getElementById("presetAftershock");
        const presetSubductionBtn = document.getElementById("presetSubduction");

        const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
        const semitonesToRatio = (st) => Math.pow(2, st / 12);

        function quantizeToScale(freq, scale, rootFreq) {
            const intervals = SCALES[scale];
            const freqs = [];
            for (let oct = -3; oct <= 4; oct++) {
                for (const iv of intervals) {
                    const f = rootFreq * Math.pow(2, oct) * semitonesToRatio(iv);
                    if (f >= 20 && f <= 10000) freqs.push(f);
                }
            }
            let nearest = freqs[0], minDist = Math.abs(freq - nearest);
            for (const f of freqs) {
                const dist = Math.abs(freq - f);
                if (dist < minDist) { minDist = dist; nearest = f; }
            }
            return nearest;
        }

        function detectZeroCrossings(data) {
            const crossings = [];
            for (let i = 1; i < data.length; i++) {
                if (data[i-1] * data[i] < 0) crossings.push(i / data.length);
            }
            return crossings;
        }

        function calculateDerivative(data, idx, win = 5) {
            if (idx < win || idx >= data.length - win) return 0;
            let sum = 0;
            for (let i = 1; i <= win; i++) sum += Math.abs(data[idx + i] - data[idx - i]);
            return sum / (2 * win);
        }

        function calculateRMS(data, idx, win = 50) {
            const start = Math.max(0, idx - win), end = Math.min(data.length, idx + win);
            let sum = 0;
            for (let i = start; i < end; i++) sum += data[i] * data[i];
            return Math.sqrt(sum / (end - start));
        }

        function formatQuakeTime(ds) {
            const d = new Date(ds);
            if (isNaN(d)) return "Invalid Date";
            const pad = n => String(n).padStart(2, '0');
            let h = d.getHours();
            const ampm = h >= 12 ? 'pm' : 'am';
            h = h % 12 || 12;
            return `${pad(d.getMonth()+1)}/${pad(d.getDate())}/${d.getFullYear()}, ${h}:${pad(d.getMinutes())}:${pad(d.getSeconds())} ${ampm}`;
        }

        function parseMiniSEED(buffer) {
            try {
                const view = new DataView(buffer);
                if (buffer.byteLength < 64) throw new Error("Buffer too small");
                const numSamples = view.getInt16(46, false);
                const dataOffset = 64;
                if (numSamples <= 0 || buffer.byteLength < dataOffset + numSamples * 4) throw new Error("Invalid sample count");
                const rawData = new Int32Array(buffer.slice(dataOffset, dataOffset + numSamples * 4));
                const maxVal = rawData.reduce((m, v) => Math.max(m, Math.abs(v)), 0);
                if (maxVal === 0) return new Float32Array(rawData.length);
                const normalized = new Float32Array(rawData.length);
                for (let i = 0; i < rawData.length; i++) normalized[i] = rawData[i] / maxVal;
                return normalized;
            } catch (e) {
                console.error("MiniSEED Error:", e);
                const fallback = new Float32Array(4096);
                for (let i = 0; i < fallback.length; i++) fallback[i] = (Math.random() * 2 - 1) * Math.exp(-i / 2000);
                return fallback;
            }
        }

        async function createReverb() {
            const len = 3.5 * audioCtx.sampleRate;
            const buf = audioCtx.createBuffer(2, len, audioCtx.sampleRate);
            for (let ch = 0; ch < 2; ch++) {
                const data = buf.getChannelData(ch);
                for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.2);
            }
            reverb = audioCtx.createConvolver();
            reverb.buffer = buf;
            reverbWetGain = audioCtx.createGain();
            reverbWetGain.gain.value = 0.4;
            reverb.connect(reverbWetGain).connect(masterGain);
        }

        function createDelay() {
            delay = audioCtx.createDelay(2.0);
            delay.delayTime.value = 0.375;
            delayFeedbackGain = audioCtx.createGain();
            delayFeedbackGain.gain.value = 0.4;
            delayWetGain = audioCtx.createGain();
            delayWetGain.gain.value = 0.25;
            delay.connect(delayFeedbackGain).connect(delay);
            delay.connect(delayWetGain).connect(masterGain);
        }

        async function fetchLatestEvent() {
            const end = new Date().toISOString();
            const start = new Date(Date.now() - FETCH_TIMESPAN_DAYS * 24 * 60 * 60 * 1000).toISOString();
            const url = `https://earthquake.usgs.gov/fdsnws/event/1/query?format=geojson&starttime=${start}&endtime=${end}&minmagnitude=${MIN_MAGNITUDE}&orderby=time`;
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error(`USGS failed: ${res.status}`);
                const data = await res.json();
                if (!data.features?.length) throw new Error("No events found");
                return data.features[0];
            } catch (e) {
                console.error(e);
                updateStatus(`Error: ${e.message}`, true);
                return null;
            }
        }

        async function fetchMiniSEED(eventTime) {
            const start = new Date(new Date(eventTime).getTime() - 5000).toISOString();
            const end = new Date(new Date(start).getTime() + SEISMIC_DATA_DURATION_S * 1000).toISOString();
            const { net, sta, loc, cha } = STATION_INFO;
            const url = `https://service.iris.edu/fdsnws/dataselect/1/query?net=${net}&sta=${sta}&loc=${loc}&cha=${cha}&starttime=${start}&endtime=${end}&format=miniseed`;
            try {
                const res = await fetch(url);
                if (!res.ok || res.status === 204) throw new Error("IRIS fetch failed");
                return await res.arrayBuffer();
            } catch (e) {
                console.error(e);
                updateStatus(`Error: ${e.message}`, true);
                return null;
            }
        }

        function initWaveformCanvas() {
            waveformCtx = waveformCanvas.getContext('2d');
            const rect = waveformCanvas.getBoundingClientRect();
            waveformCanvas.width = rect.width * devicePixelRatio;
            waveformCanvas.height = rect.height * devicePixelRatio;
            waveformCtx.scale(devicePixelRatio, devicePixelRatio);
        }

        function drawWaveform(data, playheadPos = 0) {
            if (!waveformCtx) return;
            const w = waveformCanvas.width / devicePixelRatio;
            const h = waveformCanvas.height / devicePixelRatio;
            waveformCtx.fillStyle = '#0a0a0f';
            waveformCtx.fillRect(0, 0, w, h);
            waveformCtx.strokeStyle = '#ff6f00';
            waveformCtx.lineWidth = 1;
            waveformCtx.beginPath();
            const step = Math.ceil(data.length / w);
            for (let i = 0; i < w; i++) {
                const idx = Math.floor(i * data.length / w);
                let min = 1, max = -1;
                for (let j = 0; j < step && idx + j < data.length; j++) {
                    const v = data[idx + j];
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
                const yMin = (1 - min) * h / 2, yMax = (1 - max) * h / 2;
                if (i === 0) waveformCtx.moveTo(i, yMin);
                waveformCtx.lineTo(i, yMin);
                waveformCtx.lineTo(i, yMax);
            }
            waveformCtx.stroke();
            waveformCtx.strokeStyle = '#333';
            waveformCtx.beginPath();
            waveformCtx.moveTo(0, h/2);
            waveformCtx.lineTo(w, h/2);
            waveformCtx.stroke();
            playheadEl.style.left = `${playheadPos * 100}%`;
        }

        // === SYNTH GRAIN: Uses oscillators for actual audio ===
        class SynthGrain {
            constructor(ctx, params) { this.ctx = ctx; this.params = params; }
            play(dest, startTime) {
                const { frequency, duration, waveform, pan, amplitude, attack, release, detune } = this.params;
                const osc = this.ctx.createOscillator();
                osc.type = waveform || 'sine';
                osc.frequency.value = frequency;
                osc.detune.value = detune || 0;
                const env = this.ctx.createGain();
                const att = duration * attack, rel = duration * release;
                const sus = Math.max(0, duration - att - rel);
                env.gain.setValueAtTime(0, startTime);
                env.gain.linearRampToValueAtTime(amplitude, startTime + att);
                if (sus > 0) env.gain.setValueAtTime(amplitude, startTime + att + sus);
                env.gain.linearRampToValueAtTime(0, startTime + duration);
                const panner = this.ctx.createStereoPanner();
                panner.pan.value = clamp(pan, -1, 1);
                osc.connect(env).connect(panner).connect(dest);
                osc.start(startTime);
                osc.stop(startTime + duration + 0.01);
                return osc;
            }
        }

        class GranularCloud {
            constructor(ctx, dest, type = 'texture') {
                this.ctx = ctx;
                this.destination = dest;
                this.type = type;
                this.isActive = false;
                this.schedulerId = null;
                this.density = 30;
                this.grainDuration = 0.05;
                this.durationSpread = 0.5;
                this.baseFrequency = 220;
                this.frequencySpread = 0.5;
                this.panSpread = 0.8;
                this.amplitude = 0.15;
                this.attackRatio = 0.3;
                this.releaseRatio = 0.5;
                this.waveform = 'sine';
                this.quantizeEnabled = true;
                this.scale = 'pentatonic';
                this.rootFreq = 110;
                this.outputGain = this.ctx.createGain();
                this.outputGain.gain.value = 0.6;
                this.outputGain.connect(this.destination);
            }
            setParams(p) { Object.assign(this, p); }
            start() { this.isActive = true; this.scheduleGrain(); }
            stop() { this.isActive = false; if (this.schedulerId) { clearTimeout(this.schedulerId); this.schedulerId = null; } }
            scheduleGrain() {
                if (!this.isActive) return;
                const now = this.ctx.currentTime;
                let freq = this.baseFrequency * Math.pow(2, (Math.random() - 0.5) * this.frequencySpread * 2);
                if (this.quantizeEnabled) freq = quantizeToScale(freq, this.scale, this.rootFreq);
                const dur = this.grainDuration * (1 + (Math.random() - 0.5) * this.durationSpread);
                const params = {
                    frequency: freq,
                    duration: dur,
                    waveform: this.waveform,
                    pan: (Math.random() - 0.5) * 2 * this.panSpread,
                    amplitude: this.amplitude * (0.7 + Math.random() * 0.3),
                    attack: this.attackRatio,
                    release: this.releaseRatio,
                    detune: (Math.random() - 0.5) * 20
                };
                new SynthGrain(this.ctx, params).play(this.outputGain, now);
                const interval = 1000 / this.density;
                const jitter = interval * 0.2 * (Math.random() - 0.5);
                this.schedulerId = setTimeout(() => this.scheduleGrain(), Math.max(10, interval + jitter));
            }
        }

        class RhythmCloud extends GranularCloud {
            constructor(ctx, dest, zeroCrossings) {
                super(ctx, dest, 'rhythm');
                this.zeroCrossings = zeroCrossings;
                this.crossingIndex = 0;
                this.triggerProbability = 0.7;
                this.waveform = 'triangle';
            }
            scheduleGrain() {
                if (!this.isActive) return;
                this.crossingIndex = (this.crossingIndex + 1) % Math.max(1, this.zeroCrossings.length);
                if (Math.random() < this.triggerProbability) {
                    const now = this.ctx.currentTime;
                    let freq = this.baseFrequency;
                    if (this.quantizeEnabled) freq = quantizeToScale(freq, this.scale, this.rootFreq);
                    const params = {
                        frequency: freq, duration: this.grainDuration, waveform: this.waveform,
                        pan: (Math.random() - 0.5) * 2 * this.panSpread, amplitude: this.amplitude,
                        attack: 0.05, release: 0.7, detune: 0
                    };
                    new SynthGrain(this.ctx, params).play(this.outputGain, now);
                }
                this.schedulerId = setTimeout(() => this.scheduleGrain(), 1000 / this.density);
            }
        }

        class GranularSeismicEngine {
            constructor(ctx, dest) {
                this.ctx = ctx;
                this.destination = dest;
                this.seismicData = [];
                this.zeroCrossings = [];
                this.playhead = 0;
                this.isActive = false;
                this.isFrozen = false;
                this.stretchFactor = 1.0;
                this.playbackSpeed = 0.0005;
                this.textureCloud = null;
                this.toneCloud = null;
                this.rhythmCloud = null;
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 4000;
                this.filter.Q.value = 2;
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0;
                this.filter.connect(this.masterGain);
                this.masterGain.connect(this.destination);
                this.animFrameId = null;
                this.peakDetected = false;
                this.lastPeakTime = 0;
            }
            loadSeismicData(arr) {
                this.seismicData = Array.from(arr);
                this.zeroCrossings = detectZeroCrossings(this.seismicData);
                console.log(`Loaded: ${this.seismicData.length} samples, ${this.zeroCrossings.length} zero-crossings`);
            }
            initializeClouds() {
                const rootFreq = parseFloat(rootSelect.value);
                const scale = scaleSelect.value;
                this.textureCloud = new GranularCloud(this.ctx, this.filter, 'texture');
                this.textureCloud.setParams({ density: 40, grainDuration: 0.04, baseFrequency: rootFreq * 4, frequencySpread: 1.0, panSpread: 1.0, amplitude: 0.08, attackRatio: 0.1, releaseRatio: 0.6, waveform: 'sine', scale, rootFreq });
                this.toneCloud = new GranularCloud(this.ctx, this.filter, 'tone');
                this.toneCloud.setParams({ density: 6, grainDuration: 0.25, baseFrequency: rootFreq, frequencySpread: 0.5, panSpread: 0.4, amplitude: 0.12, attackRatio: 0.4, releaseRatio: 0.4, waveform: 'triangle', scale, rootFreq });
                this.rhythmCloud = new RhythmCloud(this.ctx, this.filter, this.zeroCrossings);
                this.rhythmCloud.setParams({ density: 12, grainDuration: 0.06, baseFrequency: rootFreq * 2, frequencySpread: 0.3, panSpread: 0.7, amplitude: 0.1, triggerProbability: 0.5, waveform: 'sawtooth', scale, rootFreq });
            }
            start() {
                this.isActive = true;
                this.playhead = 0;
                this.initializeClouds();
                if (layerStates.texture) this.textureCloud.start();
                if (layerStates.tone) this.toneCloud.start();
                if (layerStates.rhythm) this.rhythmCloud.start();
                this.masterGain.gain.setTargetAtTime(0.9, this.ctx.currentTime, 1.5);
                this.modulateFromSeismic();
            }
            modulateFromSeismic() {
                if (!this.isActive) return;
                const idx = Math.floor(this.playhead * this.seismicData.length);
                const sample = this.seismicData[idx] || 0;
                const deriv = calculateDerivative(this.seismicData, idx);
                const rms = calculateRMS(this.seismicData, idx);
                const now = this.ctx.currentTime;
                const rootFreq = parseFloat(rootSelect.value);
                
                // Peak detection for Subduction Drone preset
                if (peakDetectionEnabled && !this.isFrozen) {
                    const absAmp = Math.abs(sample);
                    const currentTime = Date.now();
                    // Check if we've crossed the peak threshold and haven't triggered recently
                    if (absAmp > peakThreshold && (currentTime - this.lastPeakTime) > 3000) {
                        this.lastPeakTime = currentTime;
                        this.peakDetected = true;
                        // Trigger freeze
                        toggleFreeze();
                        console.log(`Peak detected at amplitude ${absAmp.toFixed(3)}, triggering freeze`);
                    }
                }
                
                // Amplitude -> density & filter
                const amp = Math.abs(sample);
                const targetFilter = 1500 + amp * 6000;
                if (this.textureCloud?.isActive) {
                    this.textureCloud.density = 30 + amp * 70;
                    this.textureCloud.amplitude = 0.05 + amp * 0.1;
                }
                this.filter.frequency.setTargetAtTime(clamp(targetFilter, 800, 10000), now, 0.03);
                // Derivative -> pitch spread & stereo
                const df = Math.min(1, deriv * 15);
                if (this.textureCloud?.isActive) {
                    this.textureCloud.frequencySpread = 0.3 + df * 1.2;
                    this.textureCloud.panSpread = 0.4 + df * 0.6;
                }
                if (this.toneCloud?.isActive) this.toneCloud.frequencySpread = 0.2 + df * 0.6;
                // RMS -> rhythm probability
                if (this.rhythmCloud?.isActive) {
                    this.rhythmCloud.triggerProbability = 0.3 + rms * 0.6;
                    this.rhythmCloud.baseFrequency = rootFreq * 2 * (1 + rms * 0.5);
                }
                if (this.toneCloud?.isActive) this.toneCloud.density = 5 + rms * 8;
                // Sample value -> base frequency
                if (this.textureCloud?.isActive) this.textureCloud.baseFrequency = rootFreq * 4 * (1 + sample * 0.3);
                if (!this.isFrozen) {
                    this.playhead += this.playbackSpeed / this.stretchFactor;
                    if (this.playhead >= 1) this.playhead = 0;
                }
                drawWaveform(this.seismicData, this.playhead);
                this.animFrameId = requestAnimationFrame(() => this.modulateFromSeismic());
            }
            freeze() {
                this.isFrozen = true;
                if (this.textureCloud) { this.textureCloud.density = 80; this.textureCloud.grainDuration = 0.12; this.textureCloud.frequencySpread = 0.2; }
                if (this.toneCloud) { this.toneCloud.density = 12; this.toneCloud.grainDuration = 0.4; }
            }
            unfreeze() {
                this.isFrozen = false;
                if (this.textureCloud) { this.textureCloud.density = 40; this.textureCloud.grainDuration = 0.04; this.textureCloud.frequencySpread = 1.0; }
                if (this.toneCloud) { this.toneCloud.density = 6; this.toneCloud.grainDuration = 0.25; }
            }
            setStretch(f) { this.stretchFactor = f; }
            setScale(s) { [this.textureCloud, this.toneCloud, this.rhythmCloud].forEach(c => { if (c) c.scale = s; }); }
            setRootFreq(f) {
                if (this.textureCloud) { this.textureCloud.rootFreq = f; this.textureCloud.baseFrequency = f * 4; }
                if (this.toneCloud) { this.toneCloud.rootFreq = f; this.toneCloud.baseFrequency = f; }
                if (this.rhythmCloud) { this.rhythmCloud.rootFreq = f; this.rhythmCloud.baseFrequency = f * 2; }
            }
            setLayerActive(layer, active) {
                const cloud = this[layer + 'Cloud'];
                if (cloud) { if (active && !cloud.isActive) cloud.start(); else if (!active && cloud.isActive) cloud.stop(); }
            }
            cleanup() {
                this.isActive = false;
                if (this.animFrameId) cancelAnimationFrame(this.animFrameId);
                [this.textureCloud, this.toneCloud, this.rhythmCloud].forEach(c => c?.stop());
                try { this.filter.disconnect(); this.masterGain.disconnect(); } catch(e) {}
            }
        }

        function createSubBass(rootFreq) {
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = rootFreq / 2;
            const lfo = audioCtx.createOscillator();
            lfo.type = 'sine';
            lfo.frequency.value = 0.04 + Math.random() * 0.02;
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = rootFreq / 2 * 0.02;
            const gain = audioCtx.createGain();
            gain.gain.value = 0;
            lfo.connect(lfoGain).connect(osc.frequency);
            osc.connect(gain).connect(masterGain);
            osc.start(now);
            lfo.start(now);
            gain.gain.setTargetAtTime(0.15, now, 2);
            subBassNodes = { osc, gain, lfo };
        }

        function startNewCycle() {
            if (!isPlaying) return;
            cycleCount++;
            const seed = cycleCount * 31 + Math.floor(currentQuakeInfo.mag * 10);
            const pr = n => { const x = Math.sin(seed + n * 9999) * 10000; return x - Math.floor(x); };
            const waveforms = ['sine', 'triangle', 'sawtooth'];
            const texDens = [30, 40, 50, 60, 80], tonDens = [5, 8, 10, 12, 15];
            const grDurs = [0.02, 0.03, 0.05, 0.08, 0.1, 0.15, 0.2];
            const pans = [0.3, 0.5, 0.7, 0.9, 1.0];
            const params = {
                textureDensity: texDens[Math.floor(pr(1) * texDens.length)],
                toneDensity: tonDens[Math.floor(pr(2) * tonDens.length)],
                textureWaveform: waveforms[Math.floor(pr(3) * waveforms.length)],
                toneWaveform: waveforms[Math.floor(pr(4) * waveforms.length)],
                grainDuration: grDurs[Math.floor(pr(5) * grDurs.length)],
                panSpread: pans[Math.floor(pr(6) * pans.length)]
            };
            if (granularEngine) {
                if (granularEngine.textureCloud) {
                    granularEngine.textureCloud.density = params.textureDensity;
                    granularEngine.textureCloud.waveform = params.textureWaveform;
                    granularEngine.textureCloud.panSpread = params.panSpread;
                }
                if (granularEngine.toneCloud) {
                    granularEngine.toneCloud.density = params.toneDensity;
                    granularEngine.toneCloud.waveform = params.toneWaveform;
                    granularEngine.toneCloud.grainDuration = params.grainDuration * 3;
                }
            }
            cycleInfo.innerHTML = `<div>Cycle <span class="param">#${cycleCount}</span> | Stretch: <span class="param">${granularEngine?.stretchFactor?.toFixed(2)||1}x</span></div><div><span class="layer">Texture:</span> <span class="param">${params.textureDensity} g/s • ${params.textureWaveform}</span> | <span class="layer">Tone:</span> <span class="param">${params.toneDensity} g/s • ${params.toneWaveform}</span></div><div>Grain: <span class="param">${(params.grainDuration*1000).toFixed(0)}ms</span> | Pan: <span class="param">±${(params.panSpread*100).toFixed(0)}%</span> | Scale: <span class="param">${scaleSelect.value}</span>${currentPreset ? ` | Preset: <span class="param">${currentPreset}</span>` : ''}</div>`;
        }

        function updateStatus(msg, isError = false) {
            statusInfo.innerHTML = `<span class="${isError ? 'error' : 'loading'}">${msg}</span>`;
        }

        // Preset application function
        function applyPreset(presetKey) {
            const preset = PRESETS[presetKey];
            if (!preset) return;
            
            currentPreset = preset.name;
            peakDetectionEnabled = preset.freezeOnPeak;
            
            // Update UI controls
            scaleSelect.value = preset.scale;
            rootSelect.value = String(preset.root);
            stretchSlider.value = preset.stretch;
            densitySlider.value = preset.density;
            reverbSlider.value = preset.reverb;
            
            // Update display values
            document.getElementById('stretchValue').textContent = preset.stretch.toFixed(2) + 'x';
            document.getElementById('densityValue').textContent = preset.density + ' g/s';
            document.getElementById('reverbValue').textContent = preset.reverb + '%';
            
            // Apply to engine if playing
            if (granularEngine) {
                granularEngine.setStretch(preset.stretch);
                granularEngine.setScale(preset.scale);
                granularEngine.setRootFreq(preset.root);
                if (granularEngine.textureCloud) {
                    granularEngine.textureCloud.density = preset.density;
                }
            }
            
            // Apply reverb
            if (reverbWetGain && audioCtx) {
                reverbWetGain.gain.setTargetAtTime(preset.reverb / 100 * 0.7, audioCtx.currentTime, 0.1);
            }
            
            // Update sub bass frequency
            if (subBassNodes) {
                subBassNodes.osc.frequency.setTargetAtTime(preset.root / 2, audioCtx.currentTime, 0.5);
            }
            
            // Update preset button states
            updatePresetButtonStates(presetKey);
            
            console.log(`Applied preset: ${preset.name}`, preset);
        }

        function updatePresetButtonStates(activeKey) {
            presetTectonicBtn.classList.toggle('active', activeKey === 'tectonic');
            presetAftershockBtn.classList.toggle('active', activeKey === 'aftershock');
            presetSubductionBtn.classList.toggle('active', activeKey === 'subduction');
        }

        function clearPresetState() {
            currentPreset = null;
            peakDetectionEnabled = false;
            updatePresetButtonStates(null);
        }

        async function startSonification() {
            if (isPlaying) return;
            startBtn.disabled = true;
            cycleCount = 0;
            updateStatus("Initializing Audio...");
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                if (audioCtx.state !== 'running') throw new Error("AudioContext failed");
                compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.value = -18;
                compressor.ratio.value = 4;
                compressor.attack.value = 0.003;
                compressor.release.value = 0.25;
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0;
                compressor.connect(masterGain).connect(audioCtx.destination);
                await createReverb();
                createDelay();
                updateStatus("Fetching earthquake data...");
                const event = await fetchLatestEvent();
                if (!event) { stopSonification(); return; }
                currentQuakeInfo = {
                    place: event.properties.place || "Unknown",
                    mag: event.properties.mag || 0,
                    depth: event.geometry.coordinates[2] || 0,
                    time: new Date(event.properties.time).toISOString(),
                    usgsUrl: `https://earthquake.usgs.gov/earthquakes/eventpage/${event.id}/executive`
                };
                updateStatus(`Found M${currentQuakeInfo.mag.toFixed(1)}. Fetching waveform...`);
                const miniSEED = await fetchMiniSEED(currentQuakeInfo.time);
                if (!miniSEED) { stopSonification(); return; }
                seismicData = Array.from(parseMiniSEED(miniSEED));
                if (!seismicData.length) throw new Error("Empty seismic data");
                isPlaying = true;
                initWaveformCanvas();
                drawWaveform(seismicData);
                const df = Math.min(1, currentQuakeInfo.depth / 600);
                if (reverbWetGain) reverbWetGain.gain.setTargetAtTime(0.3 + df * 0.4, audioCtx.currentTime, 0.5);
                if (delay) delay.delayTime.setTargetAtTime(0.25 + df * 0.35, audioCtx.currentTime, 0.5);
                if (delayFeedbackGain) delayFeedbackGain.gain.setTargetAtTime(0.35 + df * 0.25, audioCtx.currentTime, 0.5);
                granularEngine = new GranularSeismicEngine(audioCtx, compressor);
                granularEngine.loadSeismicData(seismicData);
                if (reverb) granularEngine.masterGain.connect(reverb);
                if (delay) granularEngine.masterGain.connect(delay);
                createSubBass(parseFloat(rootSelect.value));
                granularEngine.start();
                startNewCycle();
                const cycleInt = setInterval(() => { if (isPlaying) startNewCycle(); }, CYCLE_DURATION_S * 1000);
                activeSchedulers.push(cycleInt);
                masterGain.gain.setTargetAtTime(0.75, audioCtx.currentTime, 2.0);
                stopBtn.disabled = false;
                freezeBtn.disabled = false;
                cycleInfo.style.display = 'block';
                controlsPanel.style.display = 'block';
                presetPanel.style.display = 'block';
                const { mag, place, depth, time, usgsUrl } = currentQuakeInfo;
                statusInfo.innerHTML = `<span class="status-line">Now Playing: <strong>M${mag.toFixed(1)}</strong> ${place}</span><span class="status-line">Depth: <strong>${depth.toFixed(1)} km</strong>, Time: ${formatQuakeTime(time)}</span><span class="status-line"><a href="${usgsUrl}" target="_blank">View on USGS</a> | Station: ${STATION_INFO.net}.${STATION_INFO.sta}</span>`;
                statusInfo.className = 'info';
            } catch (e) {
                console.error(e);
                updateStatus(`Error: ${e.message}`, true);
                stopSonification();
            }
        }

        function stopSonification() {
            if (!isPlaying && !audioCtx) return;
            isPlaying = false;
            isFrozen = false;
            activeSchedulers.forEach(id => { clearInterval(id); clearTimeout(id); });
            activeSchedulers = [];
            granularEngine?.cleanup();
            granularEngine = null;
            if (subBassNodes) { try { subBassNodes.osc.stop(); subBassNodes.lfo.stop(); } catch(e){} subBassNodes = null; }
            if (audioCtx) {
                masterGain?.gain.setTargetAtTime(0, audioCtx.currentTime, 0.5);
                setTimeout(() => { audioCtx?.close(); audioCtx = null; }, 1000);
            }
            startBtn.disabled = false;
            stopBtn.disabled = true;
            freezeBtn.disabled = true;
            freezeBtn.classList.remove('freeze-active');
            freezeBtn.textContent = 'Freeze';
            cycleInfo.style.display = 'none';
            controlsPanel.style.display = 'none';
            presetPanel.style.display = 'none';
            updateStatus("Stopped. Press Start to fetch new data.");
            currentQuakeInfo = null;
            cycleCount = 0;
            clearPresetState();
        }

        function toggleFreeze() {
            if (!granularEngine) return;
            isFrozen = !isFrozen;
            if (isFrozen) { granularEngine.freeze(); freezeBtn.classList.add('freeze-active'); freezeBtn.textContent = 'Unfreeze'; }
            else { granularEngine.unfreeze(); freezeBtn.classList.remove('freeze-active'); freezeBtn.textContent = 'Freeze'; }
        }

        function toggleLayer(layer) {
            layerStates[layer] = !layerStates[layer];
            const btn = document.getElementById('toggle' + layer.charAt(0).toUpperCase() + layer.slice(1));
            btn.classList.toggle('inactive', !layerStates[layer]);
            granularEngine?.setLayerActive(layer, layerStates[layer]);
        }

        startBtn.onclick = startSonification;
        stopBtn.onclick = stopSonification;
        freezeBtn.onclick = toggleFreeze;
        document.getElementById('toggleTexture').onclick = () => toggleLayer('texture');
        document.getElementById('toggleTone').onclick = () => toggleLayer('tone');
        document.getElementById('toggleRhythm').onclick = () => toggleLayer('rhythm');
        
        // Preset button handlers
        presetTectonicBtn.onclick = () => applyPreset('tectonic');
        presetAftershockBtn.onclick = () => applyPreset('aftershock');
        presetSubductionBtn.onclick = () => applyPreset('subduction');
        
        // Slider handlers - clear preset state when manually adjusted
        stretchSlider.oninput = function() { 
            clearPresetState();
            document.getElementById('stretchValue').textContent = parseFloat(this.value).toFixed(2) + 'x'; 
            granularEngine?.setStretch(parseFloat(this.value)); 
        };
        densitySlider.oninput = function() { 
            clearPresetState();
            document.getElementById('densityValue').textContent = this.value + ' g/s'; 
            if (granularEngine?.textureCloud) granularEngine.textureCloud.density = parseInt(this.value); 
        };
        grainSizeSlider.oninput = function() { 
            clearPresetState();
            document.getElementById('grainSizeValue').textContent = this.value + 'ms'; 
            if (granularEngine?.textureCloud) granularEngine.textureCloud.grainDuration = parseInt(this.value) / 1000; 
        };
        scaleSelect.onchange = function() { 
            clearPresetState();
            granularEngine?.setScale(this.value); 
        };
        rootSelect.onchange = function() { 
            clearPresetState();
            const f = parseFloat(this.value); 
            granularEngine?.setRootFreq(f); 
            if (subBassNodes) subBassNodes.osc.frequency.setTargetAtTime(f / 2, audioCtx.currentTime, 0.5); 
        };
        reverbSlider.oninput = function() { 
            clearPresetState();
            document.getElementById('reverbValue').textContent = this.value + '%'; 
            if (reverbWetGain && audioCtx) reverbWetGain.gain.setTargetAtTime(parseInt(this.value) / 100 * 0.7, audioCtx.currentTime, 0.1); 
        };
        window.addEventListener('resize', () => { if (waveformCtx && seismicData.length) { initWaveformCanvas(); drawWaveform(seismicData, granularEngine?.playhead || 0); } });
    </script>
</body>
</html>